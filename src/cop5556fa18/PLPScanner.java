/**
* Initial code for the Scanner
* Name: Zheyu Yang
* Assignment number: Project #2
* Date Due: September 21, 2018
*/
package cop5556fa18;

import java.util.ArrayList;
import java.util.Arrays;

public class PLPScanner {
	
	@SuppressWarnings("serial")
	public static class LexicalException extends Exception {

		int pos;

		public LexicalException(String message, int pos) {
			super(message);
			this.pos = pos;
		}

		public int getPos() {
			return pos;
		}
	}
	
	public static enum Kind {
		IDENTIFIER, INTEGER_LITERAL, BOOLEAN_LITERAL, FLOAT_LITERAL,
		STRING_LITERAL, CHAR_LITERAL,
		KW_print        /* print       */,
		KW_sleep        /* sleep       */,
		KW_int          /* int         */,
		KW_float        /* float       */,
		KW_boolean      /* boolean     */,
		KW_while 		/* while 	   */,
		KW_if           /* if          */,
		KW_char         /* char        */,
		KW_abs			/* abs 		   */,
		KW_sin			/* sin 		   */,
		KW_cos			/* cos 		   */, 
		KW_atan			/* atan        */,
		KW_log			/* log 		   */,
		KW_string       /* string      */,
		OP_ASSIGN       /* =           */, 
		OP_EXCLAMATION  /* !           */,
		OP_QUESTION		/* ? 		   */,
		OP_EQ           /* ==          */,
		OP_NEQ          /* !=          */, 
		OP_GE           /* >=          */,
		OP_LE           /* <=          */,
		OP_GT           /* >           */,
		OP_LT           /* <           */,
		OP_PLUS         /* +           */,
		OP_MINUS        /* -           */,
		OP_TIMES        /* *           */,
		OP_DIV          /* /           */,
		OP_MOD          /* %           */,
		OP_POWER        /* **          */, 
		LPAREN          /* (           */,
		RPAREN          /* )           */,
		LBRACE          /* {           */, 
		RBRACE          /* }           */,
		OP_COLON		/* : 		   */,
		OP_OR			/* | 		   */,
		OP_AND			/* & 		   */, 
		SEMI            /* ;           */,
		COMMA           /* ,           */,
		//DOT             /* .           */,
		EOF;            /* end of file */
	}
	
	/**
	 * Class to represent Tokens.
	 *
	 */
	public class Token {
		public final Kind kind;
		public final int pos; // position of first character of this token in the input. Counting starts at 0
								// and is incremented for every character.
		public final int length; // number of characters in this token

		public Token(Kind kind, int pos, int length) {
			super();
			this.kind = kind;
			this.pos = pos;
			this.length = length;
		}
		
		/**
		 * Calculates and returns the line on which this token resides. The first line
		 * in the source code is line 1.
		 * 
		 * @return line number of this Token in the input.
		 */
		public int line() {
			return PLPScanner.this.line(pos) + 1;
		}

		/**
		 * Returns position in line of this token.
		 * 
		 * @param line.
		 *            The line number (starting at 1) for this token, i.e. the value
		 *            returned from Token.line()
		 * @return
		 */
		public int posInLine(int line) {
			return PLPScanner.this.posInLine(pos, line - 1) + 1;
		}

		/**
		 * Returns the position in the line of this Token in the input. Characters start
		 * counting at 1. Line termination characters belong to the preceding line.
		 * 
		 * @return
		 */
		public int posInLine() {
			return PLPScanner.this.posInLine(pos) + 1;
		}

		public String toString() {
			int line = line();
			return "[" + kind + "," +
			       String.copyValueOf(chars, pos, length) + "," +
			       pos + "," +
			       length + "," +
			       line + "," +
			       posInLine(line) + "]";
		}

		/**
		 * Since we override equals, we need to override hashCode, too.
		 * 
		 * See
		 * https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode--
		 * where it says, "If two objects are equal according to the equals(Object)
		 * method, then calling the hashCode method on each of the two objects must
		 * produce the same integer result."
		 * 
		 * This method, along with equals, was generated by eclipse
		 * 
		 */
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((kind == null) ? 0 : kind.hashCode());
			result = prime * result + length;
			result = prime * result + pos;
			return result;
		}

		/**
		 * Override equals so that two Tokens are equal if they have the same Kind, pos,
		 * and length.
		 * 
		 * This method, along with hashcode, was generated by eclipse.
		 */
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Token other = (Token) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (kind != other.kind)
				return false;
			if (length != other.length)
				return false;
			if (pos != other.pos)
				return false;
			return true;
		}

		/**
		 * used in equals to get the Scanner object this Token is associated with.
		 * 
		 * @return
		 */
		private PLPScanner getOuterType() {
			return PLPScanner.this;
		}
	}
	
	/**
	 * Array of positions of beginning of lines. lineStarts[k] is the pos of the
	 * first character in line k (starting at 0).
	 * 
	 * If the input is empty, the chars array will have one element, the synthetic
	 * EOFChar token and lineStarts will have size 1 with lineStarts[0] = 0;
	 */
	int[] lineStarts;

	int[] initLineStarts() {
		ArrayList<Integer> lineStarts = new ArrayList<Integer>();
		int pos = 0;

		for (pos = 0; pos < chars.length; pos++) {
			lineStarts.add(pos);
			char ch = chars[pos];
			while (ch != EOFChar && ch != '\n' && ch != '\r') {
				pos++;
				ch = chars[pos];
			}
			if (ch == '\r' && chars[pos + 1] == '\n') {
				pos++;
			}
		}
		// convert arrayList<Integer> to int[]
		return lineStarts.stream().mapToInt(Integer::valueOf).toArray();
	}
	
	int line(int pos) {
		int line = Arrays.binarySearch(lineStarts, pos);
		if (line < 0) {
			line = -line - 2;
		}
		return line;
	}

	public int posInLine(int pos, int line) {
		return pos - lineStarts[line];
	}

	public int posInLine(int pos) {
		int line = line(pos);
		return posInLine(pos, line);
	}
	
	/**
	 * Sentinal character added to the end of the input characters.
	 */
	static final char EOFChar = 128;

	/**
	 * The list of tokens created by the scan method.
	 */
	final ArrayList<Token> tokens;

	/**
	 * An array of characters representing the input. These are the characters from
	 * the input string plus an additional EOFchar at the end.
	 */
	final char[] chars;

	/**
	 * position of the next token to be returned by a call to nextToken
	 */
	private int nextTokenPos = 0;
	
	PLPScanner(String inputString) {
		int numChars = inputString.length();
		this.chars = Arrays.copyOf(inputString.toCharArray(), numChars + 1); // input string terminated with null char
		chars[numChars] = EOFChar;
		tokens = new ArrayList<Token>();
		lineStarts = initLineStarts();
	}
	
	private enum State {
		START, 
		HAS_EQUAL 		/* has a '=' */,
		HAS_TIMES 		/* has a '*' */, 
		HAS_EXCLAMATION /* has a '!' */,
		HAS_GT 			/* has a '>' */,
		HAS_LT 			/* has a '<' */,
		HAS_MOD			/* has a '%' */,
		IN_COMMENTS		/* the string is in comments*/,
		IN_IDENT		/* in identifier or in keyword */,
		IN_DIGIT		/* in digit  */,
		HAS_DOT			/* has a '.' */,
		IN_STRING		/* has a '"' */,
		IN_CHAR         /* has a ''' */
	}; 					// TODO: this is incomplete

	
	public PLPScanner scan() throws LexicalException {
		int pos = 0;
		State state = State.START;
		int startPos = 0;
		
		boolean hasComment = false;		//the first comment is showed before
		// TODO: this is incomplete
		while (pos < chars.length) {
			char ch = chars[pos];	
			switch (state) {
			case START: {
				startPos = pos;
				switch (ch) {
				case EOFChar: {
					tokens.add(new Token(Kind.EOF, startPos, 0));	
					if(hasComment == true)
					{
						error(pos, line(pos), posInLine(pos), "Could not find comments end");
					}
					pos++; // next iteration will terminate loop
				}
				break;
				case ' ':
				case '\t':
				case '\r':
				case '\f':	
				case '\n': {
					pos++;
				}
				break;
				case ';': {
					tokens.add(new Token(Kind.SEMI, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case '+': {
					tokens.add(new Token(Kind.OP_PLUS, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case '-': {
					tokens.add(new Token(Kind.OP_MINUS, startPos, pos - startPos + 1));
					pos++;				
				}
				break;
				case '/': {
					tokens.add(new Token(Kind.OP_DIV, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case '(': {
					tokens.add(new Token(Kind.LPAREN, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case ')': {
					tokens.add(new Token(Kind.RPAREN, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case '{': {
					tokens.add(new Token(Kind.LBRACE, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case '}': {
					tokens.add(new Token(Kind.RBRACE, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case ',': {
					tokens.add(new Token(Kind.COMMA, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case '?': {
					tokens.add(new Token(Kind.OP_QUESTION, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case ':': {
					tokens.add(new Token(Kind.OP_COLON, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case '|': {
					tokens.add(new Token(Kind.OP_OR, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case '&': {
					tokens.add(new Token(Kind.OP_AND, startPos, pos - startPos + 1));
					pos++;
				}
				break;
				case '=': {
					state = State.HAS_EQUAL;
					pos++;
				}
				break;
				case '*': {
					state = State.HAS_TIMES;
					pos++;
				}
				break;
				case '!': {
					state = State.HAS_EXCLAMATION;
					pos++;
				}
				break;
				case '>': {
					state = State.HAS_GT;
					pos++;
				}
				break;
				case '<': {
					state = State.HAS_LT;
					pos++;
				}
				break;
				case '%': {
					state = State.HAS_MOD;
					pos++;
				}
				break;
				case '"': {
					state = State.IN_STRING;
					pos++;
				}
				break;
				case '\'': {
					state = State.IN_CHAR;
					pos++;
				}
				break;
				default: {
					//check if the token is a digit or an identifier
					if(Character.isDigit(ch)) {
						//if . does not follow 0, then the 0 is an integer
						if(ch == '0' && chars[pos+1] != '.') {
							tokens.add(new Token(Kind.INTEGER_LITERAL, startPos, pos - startPos + 1));
							pos++;
							break;
						}
						state = State.IN_DIGIT;
						pos++;
					} else if(checkIdentStart(ch)) {		
						state = State.IN_IDENT;
						pos++;
					} else {
						error(pos, line(pos), posInLine(pos), "illegal char");
					}
				}
				}// switch ch
			}
			break;
			case IN_CHAR: {
				startPos = pos;
				while(true) {
					ch = chars[pos];
					if(ch == EOFChar) {
						error(pos, line(pos), posInLine(pos), "Right single quote not found");
					}else if(ch == '\'') {
						if(pos - startPos > 1) {
							error(pos, line(pos), posInLine(pos), "illegal char: range excessive");
						} else {
							tokens.add(new Token(Kind.CHAR_LITERAL, startPos - 1, pos - startPos + 2));
							pos++;
							state=State.START;
							break;
						}
					} else {
						pos++;
					}
				}
			}
			break;
			case IN_STRING: {
				startPos = pos;
				while(true) {
					ch = chars[pos];
					if(ch == EOFChar) {
						error(pos, line(pos), posInLine(pos), "right quote not found");
					}
					else if(ch == '"') {
						tokens.add(new Token(Kind.STRING_LITERAL, startPos - 1, pos - startPos + 2));
						pos++;
						state=State.START;
						break;
					} else {
						pos++;
					}
				}
			}
			break;
			case IN_IDENT: {
				startPos = pos - 1;
				ArrayList<Character> wordList = new ArrayList<Character>(); 
				while(true) {
					ch = chars[pos - 1];
					if(checkIdentPart(ch) ) {
						wordList.add(ch);
						pos++;
					} else {
						int i = 0;
						for(i = 0; i < wordList.size(); i++) {
							if(wordList.get(i) != '_') {
								break;
							}
						}
						if(i == wordList.size()) {
							error(pos - 2, line(pos - 2), posInLine(pos - 2), "illigal token: only '_'");
						}
						StringBuilder strBuilder = new StringBuilder();
						for (Character character : wordList) {
							strBuilder.append(character);
					    }
						String wordString = String.valueOf(strBuilder);
						if(wordString.equals("int")) {
							tokens.add(new Token(Kind.KW_int, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("float")) {
							tokens.add(new Token(Kind.KW_float, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("string")) {
							tokens.add(new Token(Kind.KW_string, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("print")) {
							tokens.add(new Token(Kind.KW_print, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("boolean")) {
							tokens.add(new Token(Kind.KW_boolean, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("sleep")) {
							tokens.add(new Token(Kind.KW_sleep, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("if")) {
							tokens.add(new Token(Kind.KW_if, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("char")) {
							tokens.add(new Token(Kind.KW_char, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("true") || wordString.equals("false")) {
							tokens.add(new Token(Kind.BOOLEAN_LITERAL, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("sin")) {
							tokens.add(new Token(Kind.KW_sin, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("while")) {
							tokens.add(new Token(Kind.KW_while, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("cos")) {
							tokens.add(new Token(Kind.KW_cos, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("atan")) {
							tokens.add(new Token(Kind.KW_atan, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("abs")) {
							tokens.add(new Token(Kind.KW_abs, startPos, (pos - 1) - startPos));
						} else if(wordString.equals("log")) {
							tokens.add(new Token(Kind.KW_log, startPos, (pos - 1) - startPos));
						} else {
							if(wordString.matches(".*[a-zA-z].*")) {
								//System.out.println(wordString.matches(".*[a-zA-Z].*"));
								tokens.add(new Token(Kind.IDENTIFIER, startPos, (pos - 1) - startPos));
							} else {
								error(pos - 2, line(pos - 2), posInLine(pos - 2), "illigal token: no alphabet");
							}
							
						}
						pos--;
						state = State.START;
;						break;
					}
				}			
			}
			break;
			case IN_DIGIT: {
				startPos = pos;
				ArrayList<Character> digitList = new ArrayList<Character>(); 
				int dotSum = 0;				//count the sum of dot
				boolean isInt = true;		//check the token is an integer or a decimal
				//the loop will end when one token is complete
				while(true) {
					ch = chars[pos - 1];
					if(Character.isDigit(ch)) {
						pos++;
						digitList.add(ch);
					} else if(ch == '.') {
						if(dotSum == 0) {
							//System.out.println(chars[pos]);
							if(!Character.isDigit(chars[pos])) {		
								error(pos - 1, line(pos - 1), posInLine(pos - 1), "illegal char");
							} else {
								isInt = false;
								pos++;
								dotSum++;
								digitList.add(ch);
							}
							
						} else {
							error(pos, line(pos), posInLine(pos), "illegal char: Already had one dot in a float token");
						}	
					} else {
						StringBuilder strBuilder = new StringBuilder();
						for (Character digit : digitList) {
							strBuilder.append(digit);
					    }
						String digitString = String.valueOf(strBuilder);	
						if(isInt == true) {
							if((digitString.length() > 10) || Long.parseLong(digitString) > Integer.MAX_VALUE || Long.parseLong(digitString) < Integer.MIN_VALUE)
							{
								error(pos, line(pos), posInLine(pos), "illegal char: range excessive");
							} else {
								tokens.add(new Token(Kind.INTEGER_LITERAL, startPos - 1, pos - startPos));
							}
						} else {
							digitString = digitString.substring(0,digitString.indexOf("."));
							if(digitString.length() <= 39 || Double.parseDouble(digitString) < Float.MAX_VALUE) {
								tokens.add(new Token(Kind.FLOAT_LITERAL, startPos - 1, pos - startPos));
							} else {
								error(pos, line(pos), posInLine(pos), "illegal char: range excessive");
							}
						}
						state = State.START;
						pos--;
						break;
					}
				}	
			}
			break;
			case HAS_EQUAL: {
				startPos = pos;
				//the token is 'OP_EQ' if the next character is '=', but if the next character is not '=' then the token is 'OP_ASSIGN' 
				if (ch == '=') {
					tokens.add(new Token(Kind.OP_EQ, startPos - 1, pos - startPos + 2));
					pos++;
				} else {
					tokens.add(new Token(Kind.OP_ASSIGN, startPos - 1, pos - startPos + 1));	
					//do not pos++ since the next character is a new start of the next token
				}
				//let the state back to START since a token is complete
				state = State.START;
			}
			break;
			case HAS_TIMES:	{
				startPos = pos;
				if (ch == '*') {
					tokens.add(new Token(Kind.OP_POWER, startPos - 1, pos - startPos + 2));
					pos++;		
				} else {
					tokens.add(new Token(Kind.OP_TIMES, startPos - 1, pos - startPos + 1));
				}
				state = State.START;
			}
			break;
			case HAS_EXCLAMATION: {
				startPos = pos;
				if (ch == '=') {
					tokens.add(new Token(Kind.OP_NEQ, startPos - 1, pos - startPos + 2));
					pos++;		
				} else {
					tokens.add(new Token(Kind.OP_EXCLAMATION, startPos - 1, pos - startPos + 1));
				}
				state = State.START;
			}
			break;
			case HAS_GT: {
				startPos = pos;
				if (ch == '=') {
					tokens.add(new Token(Kind.OP_GE, startPos - 1, pos - startPos + 2));
					pos++;		
				} else {
					tokens.add(new Token(Kind.OP_GT, startPos - 1,  pos - startPos + 1));				
				}
				state = State.START;
			}
			break; 
			case HAS_LT: {
				startPos = pos;
				if (ch == '=') {
					tokens.add(new Token(Kind.OP_LE, startPos - 1, pos - startPos + 2));
					pos++;		
				} else {
					tokens.add(new Token(Kind.OP_LT, startPos - 1, pos - startPos + 1));
				}
				state = State.START;
			}
			break; 
			case HAS_MOD: {
				startPos = pos;
				if(ch == '{') {
					//set hasComment to true
					hasComment = true;
					state = State.IN_COMMENTS;
				} else if(ch == '}') {
					//check if comments pair is complete
					if(hasComment == true) {
						hasComment = false;
					} else {
						tokens.add(new Token(Kind.OP_MOD, startPos - 1, pos - startPos + 1));
						state = State.START;
						pos--;
					}
					state = State.START;
				} else {
					if(hasComment == false) {
						//the symbol is just '%'
						tokens.add(new Token(Kind.OP_MOD, startPos - 1, pos - startPos + 1));
						state = State.START;
						pos--;
					} else {
						state = State.IN_COMMENTS;
					}	
				} 
				pos++;
			}
			break;
			//contents in comments will be discarded
			case IN_COMMENTS:{
				startPos = pos;
				if(ch == '%' && chars[pos + 1] == '}') {
					state = State.HAS_MOD;
					pos++;
				} else if(ch == EOFChar) {
					state = State.START;		
				} else {
					pos++;
				}
			}
			break;
			default: {
				error(pos, 0, 0, "undefined state");
			}
			}// switch state
		} // while

		return this;
	}
	//check if the first character of the token matches the grammar of the identifier
	private boolean checkIdentStart(char ch) {
		if((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '_') {
			return true;
		} else {
			return false;
		}
		
	}
	//check if a character matches the grammar of the identifier
	private boolean checkIdentPart(char ch) {
		if((ch >= 'A' && ch <= 'Z') || (ch>='a' && ch<='z') || ch == '_' || ch >= '0' && ch <= '9') {
			return true;
		} else {
			return false;
		}
		
	}
	
	private void error(int pos, int line, int posInLine, String message) throws LexicalException {
		String m = (line + 1) + ":" + (posInLine + 1) + " " + message;
		throw new LexicalException(m, pos);
	}

	/**
	 * Returns true if the internal iterator has more Tokens
	 * 
	 * @return
	 */
	public boolean hasTokens() {
		return nextTokenPos < tokens.size();
	}

	/**
	 * Returns the next Token and updates the internal iterator so that the next
	 * call to nextToken will return the next token in the list.
	 * 
	 * It is the callers responsibility to ensure that there is another Token.
	 * 
	 * Precondition: hasTokens()
	 * 
	 * @return
	 */
	public Token nextToken() {
		return tokens.get(nextTokenPos++);
	}

	/**
	 * Returns the next Token, but does not update the internal iterator. This means
	 * that the next call to nextToken or peek will return the same Token as
	 * returned by this methods.
	 * 
	 * It is the callers responsibility to ensure that there is another Token.
	 * 
	 * Precondition: hasTokens()
	 * 
	 * @return next Token.
	 */
	public Token peek() {
		return tokens.get(nextTokenPos);
	}

	/**
	 * Resets the internal iterator so that the next call to peek or nextToken will
	 * return the first Token.
	 */
	public void reset() {
		nextTokenPos = 0;
	}

	/**
	 * Returns a String representation of the list of Tokens and line starts
	 */
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append("Tokens:\n");
		for (int i = 0; i < tokens.size(); i++) {
			sb.append(tokens.get(i)).append('\n');
		}
		sb.append("Line starts:\n");
		for (int i = 0; i < lineStarts.length; i++) {
			sb.append(i).append(' ').append(lineStarts[i]).append('\n');
		}
		return sb.toString();
	}


}
